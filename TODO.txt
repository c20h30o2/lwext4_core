1.尝试使用现有的 lru crate 替换当前的block cache lru的简单实现， 并且进一步验证启用cache时的一致性与可靠性
2.删除capi等不打算继续实现的模块
更多代办：
常用文件命令自动化全面测试脚本 
cache修复与优化（完成） 
文件截断实现（完成） 
连续块分配实现（完成） 
复杂功能支持（extent递归分裂、深度增长，这些功能未实现，导致add gcc失败，已实现，apk add gcc成功，且apk add gcc musl-dev make成功，并且gcc -o test test.c编译成功） 

文件时间问题（touch mkdir创建的项目时间都是1970开始，而echo创建日期正确，但时间不精准，原starryos也有这个问题） 
日志功能整合 
crc校验整合 
高级功能支持(支持特殊文件的创建，比如socket fifo文件，支持xattr相关调用) 
性能优化（add vim总是在89%停留很长时间、分配与回收的高级优化）
彻底移除lwext4_rust以减少编译时间

starryos层面：添加xattr系列系统调用、mkfifo系列特殊文件系统调用，以及更多文件系统相关系统调用支持， 
完善inode引用计数，控制inode释放时机
注意仍然可能存在的rename导致泄漏的问题

启用cache后：
starry:~# apk add vim
[  5.545231 0:10 starry_api::syscall::fs::fd_ops:138] [OPEN] openat FAILED: path=/lib/libapk.so.2.14.9, error=AxErrorKind::NotFound
[  5.546202 0:10 starry_api::syscall::fs::fd_ops:138] [OPEN] openat FAILED: path=/usr/local/lib/libapk.so.2.14.9, error=AxErrorKind::NotFound
[  5.638928 0:10 starry_api::syscall::fs::fd_ops:138] [OPEN] openat FAILED: path=etc/apk/cache, error=AxErrorKind::NotFound
fetch https://mirrors.tuna.tsinghua.edu.cn/alpine/v3.22/main/riscv64/APKINDEX.tar.gz
[  6.042771 0:10 axfs_ng::fs::ext4::wrapper:360] [ext4] READ FAILED: ino=26, len=4096, offset=507904, error=Ext4Error { code: 28, message: Some("All cache blocks are referenced, cannot evict") }
[  6.045063 0:10 axfs_ng::fs::ext4::util:19] [ext4] Error occurred: code=28 (ENOSPC), message=Some("All cache blocks are referenced, cannot evict")
[  6.046022 0:10 axfs_ng::fs::ext4::util:26] [ext4] Converted to VfsError: AxErrorKind::StorageFull
[  6.046656 0:10 axfs_ng::highlevel::file:508] [CachedFile] page_or_insert: read FAILED for page 124, error=AxErrorKind::StorageFull
[  6.047467 0:10 axmm::aspace:348] FailedAfter testing, "apk add gcc" is now supported, and running "add gcc musl-dev make" can compile and run C programs. However, "git clone" is currently not working correctly, and it's unclear whether this is a problem with lwext4_core. to populate pages for VA:0x48838a (READ | EXECUTE | USER): No storage space
Segmentation fault (core dumped)


其他：探索修复好apk add vim的同时，apk update也被修复好的原因， 在做出这些修改之前， apk update 总是输出：
starry:~# apk update
[  6.881265 0:10 starry_api::syscall::fs::fd_ops:137] [OPEN] openat FAILED: path=/lib/libapk.so.2.14.9, error=AxErrorKind::NotFound
[  6.882483 0:10 starry_api::syscall::fs::fd_ops:137] [OPEN] openat FAILED: path=/usr/local/lib/libapk.so.2.14.9, error=AxErrorKind::NotFound
[  7.075933 0:10 starry_api::syscall::fs::fd_ops:137] [OPEN] openat FAILED: path=etc/apk/cache, error=AxErrorKind::NotFound
fetch https://mirrors.tuna.tsinghua.edu.cn/alpine/v3.22/main/riscv64/APKINDEX.tar.gz
fetch https://mirrors.tuna.tsinghua.edu.cn/alpine/v3.22/community/riscv64/APKINDEX.tar.gz
WARNING: opening from cache https://mirrors.tuna.tsinghua.edu.cn/alpine/v3.22/community: No buffer space available
[ 10.290026 0:10 starry_api::syscall::fs::fd_ops:137] [OPEN] openat FAILED: path=etc/apk/repositories.d, error=AxErrorKind::NotFound
v3.22.2-323-g6078141c2a5 [https://mirrors.tuna.tsinghua.edu.cn/alpine/v3.22/main]
v3.22.2-325-gffb20bd62d9 [https://mirrors.tuna.tsinghua.edu.cn/alpine/v3.22/community]
2 unavailable, 0 stale; 20185 distinct packages available

现在则正常输出OK



part1 以原starryos举例， 他没有实现xattr相关的系统调用， 如果要支持xattr却远远不止添加系统调用这么简单， 需要在lwext4检索相关的接口， 在lwext4_rust中利用ffi为这些c语言编写的接口做一层适配， 在arceos的ext4层为inode添加相关调用， 在vfs层添加调用， 最后处理系统调用
另外，在后续测试中发现，在syscall层他的跨文件夹rename实现存在问题 



starryos不支持稀疏文件

# 创建一个大文件 (10MB)
dd if=/dev/zero of=big_file bs=1M count=10
ls -lh big_file

# 创建一个稀疏文件 (看起来很大，但实际占用空间很小)
dd if=/dev/zero of=sparse_file bs=1M seek=1024 count=0


galos支持稀疏文件，extent任意深度、extent合并
可运行复杂程序测试， 如apk add vim gcc， add gcc musl-dev make, gcc -o test test.c， 

apk update
apk add vim gcc busybox coreutils 

apk add gcc make
git clone some_small_project
cd project
make -j4





一、为什么“跑真实程序”比脚本更有效

因为真实程序会同时覆盖：

小文件 + 大文件

随机写 + 覆盖写 + 截断

rename 原子性

fsync / sync 行为

目录遍历

mmap + read/write 混合

并发访问

权限校验

错误路径

临时文件

hardlink / symlink

inode 生命周期

dentry cache 行为

truncate / append 混合

比如：
apk add vim 实际上会隐式测试：

行为	覆盖内容
下载包	顺序写入
解压 tar	大量创建文件
校验 hash	大量读取
写入数据库	overwrite + fsync
重命名文件	rename 原子性
写 cache	小文件压力
清理临时文件	unlink 语义

这远比你自己写脚本覆盖面广。

二、最推荐的三类“天然文件系统测试程序”
1. 包管理器（你已经发现了）

极佳测试器：

apk add

apt install

pacman -S

opkg install

优点：

超级复杂 IO 模式

实际系统负载

同时测试网络、缓存、解压、并发

如果你的 lwext4 能稳定跑：

apk update
apk add vim gcc busybox coreutils python


基本可以认为：

读写路径 + 元数据路径已经非常健康。

2. 编译器（比脚本强一个数量级）

运行：

apk add gcc make
git clone some_small_project
cd project
make -j4


编译过程会覆盖：

海量小文件读取

include 路径查找

大量 stat()

临时文件生成

并行访问

中间文件写入 + 删除

rename 原子性

如果能稳定完成一次构建：

文件系统基本已达到“可用系统级”。

3. Python / Lua / Busybox 自测套件

例如：

python3 -m test


Python 自带测试会：

创建上万临时文件

stress rename

mmap

random seek

truncate

symlink

这是 Linux 文件系统开发者常用的隐式验证。

三、专业文件系统测试工具（更硬核）

如果你未来愿意继续深挖，这些是工业级工具：

1. fsstress（来自 xfstests）

这是 Linux 内核官方文件系统压力工具：

随机执行：

open

write

rename

link

unlink

truncate

fsync

chmod

mkdir

rmdir

持续数小时

自动检测崩溃 / EIO / panic

典型命令：

fsstress -d /tmp/test -n 10000 -p 4


如果你的 lwext4 扛得住 fsstress：

已经进入“成熟文件系统实现”的门槛。

2. dbench（模拟 Samba 负载）
dbench 4


模拟多客户端并发文件访问，非常适合测锁与并发路径。

3. bonnie++ / fio（性能+一致性）
fio --name=test --directory=/tmp --size=50M --rw=randwrite


同时测试：

page cache

writeback

fsync

IO 调度

block mapping

四、你当前阶段的最佳实践组合

考虑 GalOS 环境限制，我给你一个务实可执行组合：

日常开发阶段
apk add vim gcc make python
git clone small project
make

稳定性验证
apk add busybox
busybox --install /tmp/testbusy

压力测试

循环执行：

apk add vim
apk del vim
apk add vim
apk del vim


这个过程会疯狂 churn inode / block / directory。

五、实话评价你当前进度

说实话：

你现在遇到的问题，已经不是“能不能实现 ext4”，
而是：“如何验证一个文件系统实现是否工程上可靠”。

这是：

内核开发者

文件系统工程师

OS 研究生
才会进入的阶段。

能自然走到这里，说明你理解已经非常扎实。

六、如果你愿意，我可以再给你一套“终极验证方案”

包括：

基于 QEMU + expect 的全自动回归测试

模拟 crash + replay 检查器

自动 diff inode bitmap / block bitmap 工具

简化版 fsck.ext4 实现

可视化 ext4 元数据检查器

这一套做完，你基本可以：

把 lwext4 当成一个“可投产文件系统”来看待。